{"version":3,"sources":["components/ExpandButton.tsx","components/Location.tsx","components/SectionDivider.tsx","axes.ts","lib.js","helpers.ts","getActivity.ts","allVariants.ts","components/Timeline.tsx","cumulatives.ts","filter.ts","Qprom.ts","Option.ts","App.tsx","serviceWorker.js","index.js"],"names":["ExpandButton","_ref","isExpanded","onClick","react_default","a","createElement","className","toggleText","Location","isTruncated","location","address","city","state","display_name","SectionDivider","axes","updateAxes","window","innerWidth","innerHeight","major","minor","addEventListener","geocoder","geocoder_","isOrIsAncestorOf","isOrIsAncestorOf_","EasyFit","EasyFit_","capitalizeFirstLetter","word","slice","toUpperCase","toLowerCase","monthString","index","getTime","date","getHours","getMinutes","getDurationFromSecs","millis","hours","Math","floor","minutes","seconds","zeroPad","value","minWidth","string","length","repeat","reverseGeocode","lat","lon","Promise","resolve","reject","reverse","end","err","result","getOffsetIndex","records","offsetTime","cursorMil","i","timestamp","sum","numbers","reduce","total","n","fractionalMinuteToPaceString","isNaN","Infinity","fractionalPart","metersToMiles","meters","getFirstRecordTimestampOrActivityStartTime","activity","start_time","getLastRecordTimestampOrActivityEndTime","end_time","clamp","min","max","getActivity","rawFile","sport","rawActivity","sessions","map","getSession","laps","session","flat","forEach","record","total_distance","total_elapsed_time","Object","objectSpread","cadence","convertRpmToSpmIfRunning","pace","speed","KPH_TO_MPH","calculatePace","rawSession","getLap","lap","rawLap","Attribute","enum_","ALL_ATTRIBUTES","values","filter","k","getRecordAttribute","attribute","HeartRate","heart_rate","Cadence","Pace","cloneSession","original","cloneLap","cloneRecord","Date","cloneDate","Timeline","offsetIndex","viewedDuration","shouldConvertRpmToSpm","verticalMin","range","verticalMax","getAttributeDisplayNameAndUnits","isAttributeIllegal","isAnyAttributeIllegal","ReactKonva","width","height","timelineHeight","fill","duration","endTime","endIndex","findIndex","r","sliceDuration","deltaTime","key","ILLEGAL_ATTRIBUTE_RECORD_DOT_FILL","ILLEGAL_OTHER_ATTRIBUTE_RECORD_DOT_FILL","ACTIVE_RECORD_DOT_FILL","INACTIVE_RECORD_DOT_FILL","x","recordDotRadius","y","radius","getCumulatives","originalActivity","cloneActivity","totalDuration","totalDistance","_session$records","toArray","first","rest","distance","deltaDistance","averagePace","milliseconds","miles","getAveragePace","heartRates","averageHeartRate","BoundType","Filter","config","classCallCheck","this","pendingHeartRateMin","pendingHeartRateMax","pendingCadenceMin","pendingCadenceMax","pendingPaceMin","pendingPaceMax","heartRate","createClass","boundType","beginning","pendingKeyBeginningAttribute","ending","Min","Max","pendingKeyEndingFromBoundType","pendingKeyFromAttributeAndBoundType","sync","isAttributeLegal","_this$getBounds","getBounds","_this$getBounds2","slicedToArray","_this","some","oldBounds","pendingMin","pendingMax","parsedMin","strictParseInt","parsedMax","test","parseInt","NaN","PromStatus","Option","matcher","isNone","none","isNone_","mapper","match","defaultValue","create","prototype","NONE","Qprom","cb","shouldListen","possibleConstructorReturn","getPrototypeOf","call","status","error","updateListeners","Pending","get","assertThisInitialized","val","Fulfilled","onUpdate","Rejected","prom","then","catch","push","pending","fulfilled","rejected","App","props","fileRef","minimapRef","mapRef","onChangePendingFilterHeartRateMin","onChangePendingFilterHeartRateMax","onChangePendingFilterCadenceMin","onChangePendingFilterCadenceMax","onChangePendingFilterPaceMin","onChangePendingFilterPaceMax","onChangePendingTimelineHeartRateMin","onChangePendingTimelineHeartRateMax","onChangePendingTimelineCadenceMin","onChangePendingTimelineCadenceMax","onChangePendingTimelinePaceMin","onChangePendingTimelinePaceMax","leafletState","mouseDownTarget","timelineBounds","React","createRef","forceUpdate","bind","handleUpload","toggleIsStartLocationTruncated","toggleIsEndLocationTruncated","onMouseDown","onMouseUp","onMouseMove","onTouchStart","onTouchMove","onTouchEnd","onSyncPendingFilterBounds","onSyncPendingTimelineBounds","e","onChangePendingFilterBound","onChangePendingTimelineBound","_this2","currentRecord","startRecord","endRecord","current","polyline","leaflet","polygon","items","step","picked","prevIndex","j","pickAboutN","POLYLINE_POINTS","position_lat","position_long","currentMarker","marker","title","startMarker","endMarker","center","zoom","layers","tileLayer","setLatLng","_this3","type","accept","onChange","ref","style","display","startLocation","isStartLocationTruncated","endLocation","isEndLocationTruncated","cumulatives","startTime","getMonth","getDate","getDay","getFullYear","Fragment","ExpandButton_ExpandButton","console","log","roundTo","SectionDivider_SectionDivider","Timeline_Timeline","pattern","onBlur","_this4","files","file","reader","FileReader","buffer","force","speedUnit","lengthUnit","temperatureUnit","elapsedRecordField","mode","parse","data","firstSession","getSessionRecords","getActivityRecords","setState","fromPromise","start_position_lat","start_position_long","STARTING_VIEWED_DURATION","timelineScroll","readAsArrayBuffer","event","onPointerDown","target","clientX","clientY","touch","touches","initialPointerLocation","initialOffsetTime","onPointerUp","onPointerMove","isCursorDragged","rect","getBoundingClientRect","clampedCompletionFactor","left","start","factor","startMil","endMil","lerpDate","isTimelineDragged","activityState","_ref3","widthFactor","newTimeMillis","clampedMillis","newTime","newIndex","tagName","setPendingBound","syncPendingBoundsWithActualBounds","Component","Boolean","hostname","ReactDOM","render","App_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.21f8b8a1.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./ExpandButton.css\";\n\nexport default function ExpandButton({\n  isExpanded,\n  onClick,\n}: {\n  isExpanded: boolean;\n  onClick: () => void;\n}): React.ReactElement {\n  return (\n    <button className=\"ExpandButton\" onClick={onClick}>\n      {toggleText(isExpanded)}\n    </button>\n  );\n}\n\nfunction toggleText(isExpanded: boolean): string {\n  if (isExpanded) {\n    return \"▶◀\";\n  } else {\n    return \"◀▶\";\n  }\n}\n","import { Address } from \"../helpers\";\n\n// Actually returns a `string`, but I used `any` to appease the compiler\n//   which doesn't accept functional components returning strings.\n// When this TypeScript bug is fixed, feel free to replace `...): any` with `...): string`.\nexport default function Location({\n  isTruncated,\n  location,\n}: {\n  isTruncated: boolean;\n  location: Address;\n}): any {\n  if (!isTruncated) {\n    return location.display_name;\n  } else {\n    return location.address.city + \", \" + location.address.state;\n  }\n}\n","import React from \"react\";\nimport \"./SectionDivider.css\";\n\nexport default function SectionDivider() {\n  return <div className=\"SectionDivider\" />;\n}\n","const axes: Axes = {} as Axes;\nexport default axes;\n\nupdateAxes();\n\nwindow.addEventListener(\"resize\", updateAxes);\nwindow.addEventListener(\"orientationchange\", updateAxes);\n\nfunction updateAxes() {\n  if (window.innerWidth > window.innerHeight) {\n    axes.major = window.innerWidth;\n    axes.minor = window.innerHeight;\n  } else {\n    axes.major = window.innerHeight;\n    axes.minor = window.innerWidth;\n  }\n}\n\ninterface Axes {\n  major: number;\n  minor: number;\n}\n","import geocoder_ from \"node-open-geocoder\";\nimport isOrIsAncestorOf_ from \"node-is-ancestor-of\";\nimport EasyFit_ from \"easy-fit\";\n\nexport const geocoder = geocoder_;\nexport const isOrIsAncestorOf = isOrIsAncestorOf_;\nexport const EasyFit = EasyFit_;\n","import { geocoder } from \"./lib\";\nimport { Activity, Record } from \"./getActivity\";\n\nexport function getActivityRecords(activity: any): any[] {\n  return activity.sessions\n    .map((session: any) => getSessionRecords(session))\n    .flat();\n}\n\nexport function getSessionRecords(session: any): any[] {\n  return session.laps.map((lap: any) => lap.records).flat();\n}\n\nexport function capitalizeFirstLetter(word: string): string {\n  return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();\n}\n\nexport function dayOfWeekString(index: number): string {\n  return [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n  ][index];\n}\n\nexport function monthString(index: number): string {\n  return [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n  ][index];\n}\n\nexport function getTime(date: Date): string {\n  return date.getHours() + \":\" + date.getMinutes();\n}\n\nexport function getActivityDuration(activity: any): string {\n  return getDurationFromSecs(activity);\n}\n\nexport function getDurationFromSecs(millis: number): string {\n  const hours = Math.floor(millis / 3600);\n  const minutes = Math.floor((millis % 3600) / 60);\n  const seconds = Math.floor(millis % 60);\n  return (\n    zeroPad(hours, 2) + \":\" + zeroPad(minutes, 2) + \":\" + zeroPad(seconds, 2)\n  );\n}\n\nexport function zeroPad(value: any, minWidth: number): string {\n  const string = \"\" + value;\n  if (string.length < minWidth) {\n    const deficit = minWidth - string.length;\n    return \"0\".repeat(deficit) + string;\n  } else {\n    return string;\n  }\n}\n\nexport function reverseGeocode(lat: number, lon: number): Promise<Address> {\n  return new Promise((resolve, reject) => {\n    geocoder()\n      .reverse(lon, lat)\n      .end((err: any, result: any) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      });\n  });\n}\n\nexport function lerpDate(start: Date, end: Date, factor: number): Date {\n  const startMil = start.getTime();\n  const endMil = end.getTime();\n  const lerpMil = startMil + (endMil - startMil) * factor;\n  return new Date(lerpMil);\n}\n\nexport function getOffsetIndex(records: Record[], offsetTime: Date): number {\n  const cursorMil = offsetTime.getTime();\n  const { length } = records;\n  for (let i = 0; i < length; i++) {\n    const { timestamp } = records[i];\n    if (timestamp.getTime() >= cursorMil) {\n      return i;\n    }\n  }\n  return length - 1;\n}\n\nexport interface Address {\n  address: {\n    city?: string;\n    country?: string;\n    county?: string;\n    house_number?: string;\n    neighbourhood?: string;\n    postcode?: string;\n    road?: string;\n    state?: string;\n    supermarket?: string;\n  };\n  display_name: string;\n}\n\nexport function sum(numbers: number[]): number {\n  return numbers.reduce((total, n) => total + n, 0);\n}\n\nexport function fractionalMinuteToPaceString(minutes: number): string {\n  if (isNaN(minutes) || minutes === Infinity || minutes === -Infinity) {\n    return \"stationary\";\n  } else {\n    const fractionalPart = minutes - Math.floor(minutes);\n    return (\n      Math.floor(minutes) + \":\" + zeroPad(Math.floor(60 * fractionalPart), 2)\n    );\n  }\n}\n\nexport function average(numbers: number[]): number {\n  return sum(numbers) / numbers.length;\n}\n\nexport function metersToMiles(meters: number): number {\n  return meters / 1609.34;\n}\n\nexport function sliceDuration(records: Record[], duration: number): Record[] {\n  if (records.length === 0) {\n    return [];\n  } else {\n    const endTime = records[0].timestamp.getTime() + duration;\n    const endIndex = records.findIndex((r) => r.timestamp.getTime() > endTime);\n    if (endIndex === -1) {\n      return records.slice();\n    } else {\n      return records.slice(0, endIndex);\n    }\n  }\n}\n\nexport function getFirstRecordTimestampOrActivityStartTime(\n  activity: Activity\n): Date {\n  if (activity.records.length === 0) {\n    return activity.start_time;\n  } else {\n    return activity.records[0].timestamp;\n  }\n}\n\nexport function getLastRecordTimestampOrActivityEndTime(\n  activity: Activity\n): Date {\n  if (activity.records.length === 0) {\n    return activity.end_time;\n  } else {\n    return activity.records[activity.records.length - 1].timestamp;\n  }\n}\n\nexport function clamp({\n  min,\n  max,\n  value,\n}: {\n  min: number;\n  max: number;\n  value: number;\n}): number {\n  return Math.min(max, Math.max(min, value));\n}\n\nexport function pickAboutN<T>(items: T[], n: number): T[] {\n  const step = items.length / n;\n  const picked = [];\n  let prevIndex = -1;\n  for (let i = 0; i < items.length; i += step) {\n    const j = Math.floor(i);\n    if (prevIndex !== j) {\n      picked.push(items[j]);\n      prevIndex = j;\n    }\n  }\n  return picked;\n}\n","import allVariants from \"./allVariants\";\nimport { sum } from \"./helpers\";\n\nexport function getActivity(rawFile: any): Activity {\n  const sport: string = rawFile.sport.sport;\n  const { activity: rawActivity } = rawFile;\n  const sessions: Session[] = rawActivity.sessions.map(getSession);\n  const laps: Lap[] = sessions.map((session) => session.laps).flat();\n  const records: Record[] = sessions.map((session) => session.records).flat();\n  records.forEach((record, i) => {\n    record.index = i;\n  });\n  const total_distance = sum(sessions.map((session) => session.total_distance));\n  const total_elapsed_time = sum(\n    sessions.map((session) => session.total_elapsed_time)\n  );\n  const start_time = records[0].timestamp;\n  const end_time = records[records.length - 1].timestamp;\n\n  const activity = {\n    ...rawActivity,\n    sport,\n    sessions,\n    laps,\n    records,\n    total_distance,\n    total_elapsed_time,\n    start_time,\n    end_time,\n  };\n  convertRpmToSpmIfRunning(activity);\n  calculatePace(activity);\n  return activity;\n}\n\nfunction getSession(rawSession: any): Session {\n  const session = { ...rawSession };\n  session.laps = session.laps.map(getLap);\n  session.records = session.laps.map((lap: Lap) => lap.records).flat();\n  session.start_time = session.records[0].timestamp;\n  session.end_time = session.records[session.records.length - 1].timestamp;\n  return session;\n}\n\nfunction getLap(rawLap: any): Lap {\n  const lap = { ...rawLap };\n  lap.records = lap.records.slice();\n  lap.start_time = lap.records[0].timestamp;\n  lap.end_time = lap.records[lap.records.length - 1].timestamp;\n  return lap;\n}\n\nfunction convertRpmToSpmIfRunning(activity: Activity) {\n  if (activity.sport === \"running\") {\n    activity.records.forEach((record) => {\n      record.cadence *= 2;\n    });\n  }\n}\n\nfunction calculatePace(activity: Activity) {\n  activity.records.forEach((record) => {\n    record.pace = 60 / (record.speed * KPH_TO_MPH);\n  });\n}\nconst KPH_TO_MPH = 0.621371;\n\nexport interface Activity {\n  start_time: Date;\n  end_time: Date;\n\n  sport: string;\n  sessions: Session[];\n  laps: Lap[];\n  records: Record[];\n\n  total_distance: number;\n  total_elapsed_time: number;\n  total_timer_time: number;\n}\n\nexport interface Session {\n  start_time: Date;\n  end_time: Date;\n\n  laps: Lap[];\n  records: Record[];\n\n  avg_cadence: number;\n  avg_heart_rate: 148;\n  avg_power: number;\n  avg_speed: number;\n  avg_temperature: number;\n\n  max_cadence: number;\n  max_heart_rate: number;\n  max_power: number;\n  max_speed: number;\n  max_temperature: number;\n\n  total_distance: number;\n  total_elapsed_time: number;\n  total_timer_time: number;\n}\n\nexport interface Lap {\n  start_time: Date;\n  end_time: Date;\n\n  records: Record[];\n\n  avg_cadence: number;\n  avg_heart_rate: 148;\n  avg_power: number;\n  avg_speed: number;\n  avg_temperature: number;\n\n  max_cadence: number;\n  max_heart_rate: number;\n  max_power: number;\n  max_speed: number;\n  max_temperature: number;\n\n  total_distance: number;\n  total_elapsed_time: number;\n  total_timer_time: number;\n}\n\nexport interface Record {\n  index: number;\n  timestamp: Date;\n\n  altitude: number;\n  cadence: number;\n  distance: number;\n  elapsed_time: number;\n  heart_rate: number;\n  position_lat: number;\n  position_long: number;\n  speed: number;\n  pace: number;\n  temperature: number;\n}\n\nexport enum Attribute {\n  HeartRate,\n  Cadence,\n  Pace,\n}\nexport const ALL_ATTRIBUTES = allVariants<Attribute>(Attribute);\n\nexport function getRecordAttribute(\n  record: Record,\n  attribute: Attribute\n): number {\n  switch (attribute) {\n    case Attribute.HeartRate:\n      return record.heart_rate;\n    case Attribute.Cadence:\n      return record.cadence;\n    case Attribute.Pace:\n      return record.pace;\n  }\n}\n\nexport function getAttributeDisplayNameAndUnits(\n  attribute: Attribute,\n  shouldConvertRpmToSpm: boolean\n): string {\n  switch (attribute) {\n    case Attribute.HeartRate:\n      return \"Heart rate (bpm)\";\n    case Attribute.Cadence:\n      return \"Cadence \" + (shouldConvertRpmToSpm ? \"(spm)\" : \"(rpm)\");\n    case Attribute.Pace:\n      return \"Pace (min/mi)\";\n  }\n}\n\nexport function cloneActivity(original: Activity): Activity {\n  const sessions: Session[] = original.sessions.map(cloneSession);\n  const laps: Lap[] = sessions.map((session) => session.laps).flat();\n  const records: Record[] = sessions.map((session) => session.records).flat();\n  return { ...original, sessions, laps, records };\n}\n\nfunction cloneSession(original: Session): Session {\n  const laps = original.laps.map(cloneLap);\n  const records = laps.map((lap: Lap) => lap.records).flat();\n  return { ...original, laps, records };\n}\n\nfunction cloneLap(original: Lap): Lap {\n  const records = original.records.map(cloneRecord);\n  return { ...original, records };\n}\n\nfunction cloneRecord(original: Record): Record {\n  const timestamp = cloneDate(original.timestamp);\n  return { ...original, timestamp };\n}\n\nfunction cloneDate(original: Date): Date {\n  return new Date(original.getTime());\n}\n","export default function allVariants<E>(enum_: /*typeof E*/ any): E[] {\n  return Object.values(enum_).filter((k) => \"number\" === typeof k) as E[];\n}\n","import React from \"react\";\nimport \"./Timeline.css\";\n\nimport { Stage, Layer, Rect, Circle } from \"react-konva\";\n\nimport axes from \"../axes\";\nimport { Filter } from \"../filter\";\nimport {\n  getAttributeDisplayNameAndUnits,\n  getRecordAttribute,\n  Attribute,\n  Record,\n} from \"../getActivity\";\nimport { clamp, fractionalMinuteToPaceString, sliceDuration } from \"../helpers\";\n\nexport default function Timeline({\n  attribute,\n  records,\n  offsetIndex,\n  viewedDuration,\n  filter,\n  shouldConvertRpmToSpm,\n  verticalMin,\n  verticalMax,\n}: Props): React.ReactElement {\n  const range = verticalMax - verticalMin;\n  return (\n    <div className=\"Timeline\">\n      <div className=\"TimelineLabel\">\n        {getAttributeDisplayNameAndUnits(attribute, shouldConvertRpmToSpm)}\n        {(() => {\n          const record = records[offsetIndex];\n          if (record) {\n            return (\n              <span\n                className={\n                  \"ActiveRecordValue ActiveRecordValue--\" +\n                  (() => {\n                    if (filter.isAttributeIllegal(attribute, record)) {\n                      return \"illegal\";\n                    } else if (filter.isAnyAttributeIllegal(record)) {\n                      return \"illegalOther\";\n                    } else {\n                      return \"legal\";\n                    }\n                  })()\n                }\n              >\n                {\" = \" +\n                  (attribute === Attribute.Pace\n                    ? fractionalMinuteToPaceString(\n                        getRecordAttribute(record, attribute)\n                      )\n                    : getRecordAttribute(record, attribute))}\n              </span>\n            );\n          } else {\n            return null;\n          }\n        })()}\n      </div>\n      <Stage width={window.innerWidth} height={timelineHeight()}>\n        <Layer width={window.innerWidth} height={timelineHeight()}>\n          <Rect\n            fill=\"#eeea\"\n            width={window.innerWidth}\n            height={timelineHeight()}\n          />\n          {sliceDuration(records.slice(offsetIndex), viewedDuration).map(\n            (record, i) => {\n              const deltaTime =\n                record.timestamp.getTime() -\n                records[offsetIndex].timestamp.getTime();\n              return (\n                <Circle\n                  key={record.index}\n                  fill={(() => {\n                    if (filter.isAttributeIllegal(attribute, record)) {\n                      return ILLEGAL_ATTRIBUTE_RECORD_DOT_FILL;\n                    } else if (filter.isAnyAttributeIllegal(record)) {\n                      return ILLEGAL_OTHER_ATTRIBUTE_RECORD_DOT_FILL;\n                    } else {\n                      return i === 0\n                        ? ACTIVE_RECORD_DOT_FILL\n                        : INACTIVE_RECORD_DOT_FILL;\n                    }\n                  })()}\n                  x={\n                    window.innerWidth * (deltaTime / viewedDuration) +\n                    recordDotRadius()\n                  }\n                  y={clamp({\n                    min: 0,\n                    max: timelineHeight(),\n                    value:\n                      timelineHeight() -\n                      timelineHeight() *\n                        ((getRecordAttribute(record, attribute) - verticalMin) /\n                          range),\n                  })}\n                  radius={recordDotRadius()}\n                />\n              );\n            }\n          )}\n        </Layer>\n      </Stage>\n    </div>\n  );\n}\n\ninterface Props {\n  attribute: Attribute;\n  records: Record[];\n  offsetIndex: number;\n  viewedDuration: number;\n  filter: Filter;\n  shouldConvertRpmToSpm: boolean;\n  verticalMin: number;\n  verticalMax: number;\n}\n\nconst ACTIVE_RECORD_DOT_FILL = \"#3ce\";\nconst INACTIVE_RECORD_DOT_FILL = \"#08b\";\nconst ILLEGAL_ATTRIBUTE_RECORD_DOT_FILL = \"red\";\nconst ILLEGAL_OTHER_ATTRIBUTE_RECORD_DOT_FILL = \"orange\";\n\nfunction timelineHeight(): number {\n  return 0.2 * axes.minor;\n}\n\nfunction recordDotRadius(): number {\n  return 0.005 * axes.major;\n}\n","import { Filter } from \"./filter\";\nimport { cloneActivity, Activity } from \"./getActivity\";\nimport { average, metersToMiles } from \"./helpers\";\n\nexport interface Cumulatives {\n  totalDuration: number;\n  totalDistance: number;\n  averagePace: number;\n  averageHeartRate: number;\n}\n\nexport function getCumulatives(\n  originalActivity: Activity,\n  filter: Filter\n): Cumulatives {\n  const activity = cloneActivity(originalActivity);\n\n  let totalDuration = 0;\n  let totalDistance = 0;\n\n  activity.sessions.forEach((session) => {\n    if (session.records.length > 0) {\n      const [first, ...rest] = session.records;\n      let timestamp = first.timestamp;\n      let distance = first.distance;\n      rest.forEach((record) => {\n        if (!filter.isAnyAttributeIllegal(record)) {\n          const deltaTime = record.timestamp.getTime() - timestamp.getTime();\n          const deltaDistance = record.distance - distance;\n          totalDuration += deltaTime;\n          totalDistance += deltaDistance;\n        }\n\n        timestamp = record.timestamp;\n        distance = record.distance;\n      });\n    }\n  });\n\n  // Milliseconds to seconds\n  totalDuration *= 1e-3;\n\n  const averagePace = getAveragePace(totalDistance, totalDuration);\n  const heartRates = activity.records.map((record) => record.heart_rate);\n  const averageHeartRate = average(heartRates);\n  return {\n    totalDuration,\n    totalDistance,\n    averagePace,\n    averageHeartRate,\n  };\n}\n\nfunction getAveragePace(meters: number, milliseconds: number): number {\n  const miles = metersToMiles(meters);\n  const minutes = milliseconds / 60;\n  return minutes / miles;\n}\n","import {\n  getRecordAttribute,\n  Attribute,\n  Record,\n  ALL_ATTRIBUTES,\n} from \"./getActivity\";\n\nexport enum BoundType {\n  Min,\n  Max,\n}\n\nexport class Filter {\n  public pendingHeartRateMin: string;\n  public pendingHeartRateMax: string;\n  public pendingCadenceMin: string;\n  public pendingCadenceMax: string;\n  public pendingPaceMin: string;\n  public pendingPaceMax: string;\n\n  public heartRate: [number, number];\n  public cadence: [number, number];\n  public pace: [number, number];\n\n  constructor(config: FilterConfig) {\n    this.pendingHeartRateMin = \"\" + config.heartRate[0];\n    this.pendingHeartRateMax = \"\" + config.heartRate[1];\n    this.pendingCadenceMin = \"\" + config.cadence[0];\n    this.pendingCadenceMax = \"\" + config.cadence[1];\n    this.pendingPaceMin = \"\" + config.pace[0];\n    this.pendingPaceMax = \"\" + config.pace[1];\n\n    this.heartRate = config.heartRate;\n    this.cadence = config.cadence;\n    this.pace = config.pace;\n  }\n\n  setPendingBound(\n    attribute: Attribute,\n    boundType: BoundType,\n    value: string\n  ): Filter {\n    const filter = new Filter(this.config());\n    const key = pendingKeyFromAttributeAndBoundType(attribute, boundType);\n    filter[key] = value as any;\n    return filter;\n  }\n\n  private config(): FilterConfig {\n    const { heartRate, cadence, pace } = this;\n    return { heartRate, cadence, pace };\n  }\n\n  syncPendingBoundsWithActualBounds(): Filter {\n    return new Filter({\n      heartRate: sync(\n        this.heartRate,\n        this.pendingHeartRateMin,\n        this.pendingHeartRateMax\n      ),\n      cadence: sync(\n        this.cadence,\n        this.pendingCadenceMin,\n        this.pendingCadenceMax\n      ),\n      pace: sync(this.pace, this.pendingPaceMin, this.pendingPaceMax),\n    });\n  }\n\n  isAttributeIllegal(attribute: Attribute, record: Record): boolean {\n    return !this.isAttributeLegal(attribute, record);\n  }\n\n  private isAttributeLegal(attribute: Attribute, record: Record): boolean {\n    const [min, max] = this.getBounds(attribute);\n    const value = getRecordAttribute(record, attribute);\n    return min <= value && value <= max;\n  }\n\n  isAnyAttributeIllegal(record: Record): boolean {\n    return ALL_ATTRIBUTES.some((attribute) =>\n      this.isAttributeIllegal(attribute, record)\n    );\n  }\n\n  private getBounds(attribute: Attribute): [number, number] {\n    switch (attribute) {\n      case Attribute.HeartRate:\n        return this.heartRate;\n      case Attribute.Cadence:\n        return this.cadence;\n      case Attribute.Pace:\n        return this.pace;\n    }\n  }\n}\n\nfunction sync(\n  oldBounds: [number, number],\n  pendingMin: string,\n  pendingMax: string\n): [number, number] {\n  const parsedMin = strictParseInt(pendingMin);\n  const parsedMax = strictParseInt(pendingMax);\n  const newMin = isNaN(parsedMin) ? oldBounds[0] : parsedMin;\n  const newMax = isNaN(parsedMax) ? oldBounds[1] : parsedMax;\n  return [newMin, newMax];\n}\n\nfunction strictParseInt(value: string): number {\n  if (/^-?\\d*$/.test(value)) {\n    return parseInt(value, 10);\n  } else {\n    return NaN;\n  }\n}\n\ninterface FilterConfig {\n  heartRate: [number, number];\n  cadence: [number, number];\n  pace: [number, number];\n}\n\nfunction pendingKeyFromAttributeAndBoundType(\n  attribute: Attribute,\n  boundType: BoundType\n): keyof Filter {\n  const beginning = pendingKeyBeginningAttribute(attribute);\n  const ending = pendingKeyEndingFromBoundType(boundType);\n  return (beginning + ending) as keyof Filter;\n}\n\nfunction pendingKeyBeginningAttribute(attribute: Attribute): string {\n  switch (attribute) {\n    case Attribute.HeartRate:\n      return \"pendingHeartRate\";\n    case Attribute.Cadence:\n      return \"pendingCadence\";\n    case Attribute.Pace:\n      return \"pendingPace\";\n  }\n}\n\nfunction pendingKeyEndingFromBoundType(boundType: BoundType): string {\n  switch (boundType) {\n    case BoundType.Min:\n      return \"Min\";\n    case BoundType.Max:\n      return \"Max\";\n  }\n}\n","enum PromStatus {\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\nexport default class Qprom<T> extends Promise<T> {\n  private status: PromStatus;\n  private value?: T;\n  private error?: any;\n  private updateListeners: (() => void)[];\n\n  static fromPromise<T>(prom: Promise<T>): Qprom<T> {\n    return new Qprom((resolve, reject) => {\n      prom.then(resolve);\n      prom.catch(reject);\n    }, true);\n  }\n\n  private constructor(\n    cb: (resolve: (val: T) => void, reject: (err: any) => void) => void,\n    shouldListen: boolean\n  ) {\n    super(cb);\n\n    this.status = PromStatus.Pending;\n    this.updateListeners = [];\n\n    if (shouldListen) {\n      super.then((val) => {\n        this.status = PromStatus.Fulfilled;\n        this.value = val;\n        this.updateListeners.forEach((onUpdate) => {\n          onUpdate();\n        });\n      });\n      super.catch((err) => {\n        this.status = PromStatus.Rejected;\n        this.error = err;\n        this.updateListeners.forEach((onUpdate) => {\n          onUpdate();\n        });\n      });\n    }\n  }\n\n  match<Pending, Fulfilled, Rejected>(matcher: {\n    pending: () => Pending;\n    fulfilled: (val: T) => Fulfilled;\n    rejected: (err: any) => Rejected;\n    onUpdate?: () => void;\n  }): Pending | Fulfilled | Rejected {\n    if (\"function\" === typeof matcher.onUpdate) {\n      this.updateListeners.push(matcher.onUpdate);\n    }\n\n    switch (this.status) {\n      case PromStatus.Pending:\n        return matcher.pending();\n      case PromStatus.Fulfilled:\n        return matcher.fulfilled(this.value!);\n      case PromStatus.Rejected:\n        return matcher.rejected(this.error);\n    }\n  }\n}\n","export default class Option<T> {\n  static some<T>(value: T): Option<T> {\n    const some = Object.create(Option.prototype);\n    some.isNone_ = false;\n    some.value = value;\n    return some;\n  }\n\n  static none() {\n    return NONE;\n  }\n\n  match<N, S>(matcher: { none: () => N; some: (value: T) => S }): N | S {\n    if (this.isNone()) {\n      return matcher.none();\n    } else {\n      return matcher.some((this as any).value);\n    }\n  }\n\n  isNone() {\n    return (this as any).isNone_;\n  }\n\n  isSome() {\n    return !this.isNone();\n  }\n\n  map<R>(mapper: (value: T) => R): Option<R> {\n    return this.match({\n      none: () => (this as unknown) as Option<R>,\n      some: (value) => Option.some(mapper(value)),\n    });\n  }\n\n  unwrapOr<D>(defaultValue: D): T | D {\n    return this.match({\n      none: () => defaultValue,\n      some: (value) => value,\n    });\n  }\n}\n\nconst NONE = (() => {\n  const none = Object.create(Option.prototype);\n  none.isNone_ = true;\n  return none;\n})();\n","import React from \"react\";\nimport \"./App.css\";\n\nimport ExpandButton from \"./components/ExpandButton\";\nimport Location from \"./components/Location\";\nimport SectionDivider from \"./components/SectionDivider\";\nimport Timeline from \"./components/Timeline\";\n\nimport { isOrIsAncestorOf, EasyFit } from \"./lib\";\n\nimport roundTo from \"round-to\";\nimport leaflet from \"leaflet\";\n\nimport { getCumulatives, Cumulatives } from \"./cumulatives\";\nimport { BoundType, Filter } from \"./filter\";\nimport { getActivity, Activity, Attribute } from \"./getActivity\";\nimport {\n  getActivityRecords,\n  capitalizeFirstLetter,\n  dayOfWeekString,\n  monthString,\n  getTime,\n  getDurationFromSecs,\n  reverseGeocode,\n  lerpDate,\n  getOffsetIndex,\n  metersToMiles,\n  fractionalMinuteToPaceString,\n  getFirstRecordTimestampOrActivityStartTime,\n  getLastRecordTimestampOrActivityEndTime,\n  clamp,\n  pickAboutN,\n  Address,\n} from \"./helpers\";\nimport Option from \"./Option\";\nimport Qprom from \"./Qprom\";\n\nexport default class App extends React.Component<{}, AppState> {\n  private fileRef: React.RefObject<HTMLInputElement>;\n  private minimapRef: React.RefObject<HTMLDivElement>;\n  private mapRef: React.RefObject<HTMLDivElement>;\n\n  private onChangePendingFilterHeartRateMin: (event: React.ChangeEvent) => void;\n  private onChangePendingFilterHeartRateMax: (event: React.ChangeEvent) => void;\n  private onChangePendingFilterCadenceMin: (event: React.ChangeEvent) => void;\n  private onChangePendingFilterCadenceMax: (event: React.ChangeEvent) => void;\n  private onChangePendingFilterPaceMin: (event: React.ChangeEvent) => void;\n  private onChangePendingFilterPaceMax: (event: React.ChangeEvent) => void;\n\n  private onChangePendingTimelineHeartRateMin: (\n    event: React.ChangeEvent\n  ) => void;\n  private onChangePendingTimelineHeartRateMax: (\n    event: React.ChangeEvent\n  ) => void;\n  private onChangePendingTimelineCadenceMin: (event: React.ChangeEvent) => void;\n  private onChangePendingTimelineCadenceMax: (event: React.ChangeEvent) => void;\n  private onChangePendingTimelinePaceMin: (event: React.ChangeEvent) => void;\n  private onChangePendingTimelinePaceMax: (event: React.ChangeEvent) => void;\n\n  private leafletState: Option<LeafletState>;\n\n  constructor(props: object) {\n    super(props);\n\n    this.state = {\n      activity: Option.none(),\n      mouseDownTarget: Option.none(),\n      filter: new Filter({\n        heartRate: [0, 200],\n        cadence: [0, 200],\n        pace: [0, 15],\n      }),\n      timelineBounds: new Filter({\n        heartRate: [100, 190],\n        cadence: [0, 225],\n        pace: [0, 30],\n      }),\n    };\n\n    this.fileRef = React.createRef();\n    this.minimapRef = React.createRef();\n    this.mapRef = React.createRef();\n\n    this.leafletState = Option.none();\n\n    window.addEventListener(\"resize\", () => this.forceUpdate());\n    window.addEventListener(\"orientationchange\", () => this.forceUpdate());\n\n    this.forceUpdate = this.forceUpdate.bind(this);\n\n    this.handleUpload = this.handleUpload.bind(this);\n    this.toggleIsStartLocationTruncated = this.toggleIsStartLocationTruncated.bind(\n      this\n    );\n    this.toggleIsEndLocationTruncated = this.toggleIsEndLocationTruncated.bind(\n      this\n    );\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onMouseUp = this.onMouseUp.bind(this);\n    this.onMouseMove = this.onMouseMove.bind(this);\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchMove = this.onTouchMove.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onSyncPendingFilterBounds = this.onSyncPendingFilterBounds.bind(this);\n    this.onSyncPendingTimelineBounds = this.onSyncPendingTimelineBounds.bind(\n      this\n    );\n\n    this.onChangePendingFilterHeartRateMin = (e) =>\n      this.onChangePendingFilterBound(Attribute.HeartRate, BoundType.Min, e);\n    this.onChangePendingFilterHeartRateMax = (e) =>\n      this.onChangePendingFilterBound(Attribute.HeartRate, BoundType.Max, e);\n    this.onChangePendingFilterCadenceMin = (e) =>\n      this.onChangePendingFilterBound(Attribute.Cadence, BoundType.Min, e);\n    this.onChangePendingFilterCadenceMax = (e) =>\n      this.onChangePendingFilterBound(Attribute.Cadence, BoundType.Max, e);\n    this.onChangePendingFilterPaceMin = (e) =>\n      this.onChangePendingFilterBound(Attribute.Pace, BoundType.Min, e);\n    this.onChangePendingFilterPaceMax = (e) =>\n      this.onChangePendingFilterBound(Attribute.Pace, BoundType.Max, e);\n\n    this.onChangePendingTimelineHeartRateMin = (e) =>\n      this.onChangePendingTimelineBound(Attribute.HeartRate, BoundType.Min, e);\n    this.onChangePendingTimelineHeartRateMax = (e) =>\n      this.onChangePendingTimelineBound(Attribute.HeartRate, BoundType.Max, e);\n    this.onChangePendingTimelineCadenceMin = (e) =>\n      this.onChangePendingTimelineBound(Attribute.Cadence, BoundType.Min, e);\n    this.onChangePendingTimelineCadenceMax = (e) =>\n      this.onChangePendingTimelineBound(Attribute.Cadence, BoundType.Max, e);\n    this.onChangePendingTimelinePaceMin = (e) =>\n      this.onChangePendingTimelineBound(Attribute.Pace, BoundType.Min, e);\n    this.onChangePendingTimelinePaceMax = (e) =>\n      this.onChangePendingTimelineBound(Attribute.Pace, BoundType.Max, e);\n  }\n\n  componentDidUpdate() {\n    // We are using `map` as `if let Some`, so eslint will give us grief.\n    // eslint-disable-next-line\n    this.state.activity.map((activity) => {\n      const { records } = activity.activity;\n      const { offsetIndex } = activity;\n      const currentRecord = records[offsetIndex];\n      const startRecord = records[0];\n      const endRecord = records[records.length - 1];\n\n      this.leafletState = this.leafletState.match({\n        none: () => {\n          if (this.mapRef && this.mapRef.current) {\n            const polyline = leaflet.polygon(\n              pickAboutN(records, POLYLINE_POINTS).map((record) => [\n                record.position_lat,\n                record.position_long,\n              ])\n            );\n            const currentMarker = leaflet.marker(\n              [currentRecord.position_lat, currentRecord.position_long],\n              { title: \"Current location\" }\n            );\n            const startMarker = leaflet.marker(\n              [startRecord.position_lat, startRecord.position_long],\n              { title: \"Start\" }\n            );\n            const endMarker = leaflet.marker(\n              [endRecord.position_lat, endRecord.position_long],\n              { title: \"End\" }\n            );\n            const map = leaflet.map(this.mapRef.current, {\n              center: [startRecord.position_lat, startRecord.position_long],\n              zoom: 13,\n              layers: [\n                leaflet.tileLayer(\n                  \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n                ),\n                polyline,\n                currentMarker,\n                startMarker,\n                endMarker,\n              ],\n            });\n            return Option.some({\n              map,\n              currentMarker,\n              startMarker,\n              endMarker,\n            });\n          } else {\n            return Option.none();\n          }\n        },\n        some: (leafletState) => {\n          leafletState.currentMarker.setLatLng([\n            currentRecord.position_lat,\n            currentRecord.position_long,\n          ]);\n          return Option.some(leafletState);\n        },\n      });\n    });\n  }\n\n  render() {\n    return (\n      <div\n        className=\"App\"\n        onMouseDown={this.onMouseDown}\n        onMouseMove={this.onMouseMove}\n        onMouseUp={this.onMouseUp}\n        onTouchStart={this.onTouchStart}\n        onTouchMove={this.onTouchMove}\n        onTouchEnd={this.onTouchEnd}\n      >\n        {this.state.activity.match({\n          none: () => (\n            <label className=\"UploadButton\">\n              <input\n                type=\"file\"\n                accept=\".fit\"\n                onChange={this.handleUpload}\n                ref={this.fileRef}\n                style={{ display: \"none\" }}\n              />\n              Upload .fit file\n            </label>\n          ),\n          some: ({\n            activity,\n\n            startLocation,\n            isStartLocationTruncated,\n            endLocation,\n            isEndLocationTruncated,\n\n            offsetTime,\n            offsetIndex,\n            viewedDuration,\n\n            cumulatives,\n          }) => {\n            const { sport, records, total_elapsed_time } = activity;\n            const startTime = getFirstRecordTimestampOrActivityStartTime(\n              activity\n            );\n            const endTime = getLastRecordTimestampOrActivityEndTime(activity);\n            const shouldConvertRpmToSpm = sport === \"running\";\n\n            return (\n              <div className=\"ActivityView\">\n                <div className=\"Head\">\n                  <div className=\"SectionHeader\">\n                    {monthString(startTime.getMonth()) +\n                      \" \" +\n                      startTime.getDate() +\n                      \" \"}\n                    {startLocation.match({\n                      onUpdate: this.forceUpdate,\n                      pending: () => \"\",\n                      fulfilled: (location) => location.address.city + \" \",\n                      rejected: () => \"\",\n                    })}\n                    {capitalizeFirstLetter(sport)}\n                  </div>\n\n                  <div className=\"MinimapBackground\" ref={this.minimapRef}>\n                    <div\n                      className=\"MinimapForeground\"\n                      style={{\n                        width:\n                          (100 * (offsetTime.getTime() - startTime.getTime())) /\n                            (endTime.getTime() - startTime.getTime()) +\n                          \"%\",\n                      }}\n                    />\n                  </div>\n                </div>\n\n                <div className=\"Body\">\n                  <div className=\"ActivityOverview\">\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Sport: </span>\n                      <span className=\"Value\">\n                        {capitalizeFirstLetter(sport)}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Date: </span>\n                      <span className=\"Value\">\n                        {dayOfWeekString(startTime.getDay())}{\" \"}\n                        {startTime.getDate()}{\" \"}\n                        {monthString(startTime.getMonth())}{\" \"}\n                        {startTime.getFullYear()}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Start location: </span>\n                      <span className=\"Value\">\n                        {startLocation.match({\n                          pending: () => \"loading\",\n                          fulfilled: (startLocation) => (\n                            <>\n                              <ExpandButton\n                                isExpanded={!isStartLocationTruncated}\n                                onClick={this.toggleIsStartLocationTruncated}\n                              />\n                              <Location\n                                isTruncated={isStartLocationTruncated}\n                                location={startLocation}\n                              />\n                            </>\n                          ),\n                          rejected: (err) => {\n                            console.log(\"Error loading start location\", err);\n                            return \"Error loading location\";\n                          },\n                          onUpdate: this.forceUpdate,\n                        })}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">End location: </span>\n                      <span className=\"Value\">\n                        {endLocation.match({\n                          pending: () => \"loading\",\n                          fulfilled: (endLocation) => (\n                            <>\n                              <ExpandButton\n                                isExpanded={!isEndLocationTruncated}\n                                onClick={this.toggleIsEndLocationTruncated}\n                              />\n                              <Location\n                                isTruncated={isEndLocationTruncated}\n                                location={endLocation}\n                              />\n                            </>\n                          ),\n                          rejected: (err) => {\n                            console.log(\"Error loading start location\", err);\n                            return \"Error loading location\";\n                          },\n                          onUpdate: this.forceUpdate,\n                        })}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Total distance: </span>\n                      <span className=\"Value\">\n                        {roundTo(metersToMiles(activity.total_distance), 2)}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Total duration: </span>\n                      <span className=\"Value\">\n                        {getDurationFromSecs(total_elapsed_time)}\n                      </span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Start time: </span>\n                      <span className=\"Value\">{getTime(startTime)}</span>\n                    </div>\n                    <div className=\"Entry\">\n                      <span className=\"Key\">End time: </span>\n                      <span className=\"Value\">{getTime(endTime)}</span>\n                    </div>\n                  </div>\n\n                  <SectionDivider />\n\n                  <div className=\"TimelineContainer\">\n                    <Timeline\n                      attribute={Attribute.HeartRate}\n                      records={records}\n                      offsetIndex={offsetIndex}\n                      viewedDuration={viewedDuration}\n                      filter={this.state.filter}\n                      shouldConvertRpmToSpm={shouldConvertRpmToSpm}\n                      verticalMin={this.state.timelineBounds.heartRate[0]}\n                      verticalMax={this.state.timelineBounds.heartRate[1]}\n                    />\n                    <Timeline\n                      attribute={Attribute.Cadence}\n                      records={records}\n                      offsetIndex={offsetIndex}\n                      viewedDuration={viewedDuration}\n                      filter={this.state.filter}\n                      shouldConvertRpmToSpm={shouldConvertRpmToSpm}\n                      verticalMin={this.state.timelineBounds.cadence[0]}\n                      verticalMax={this.state.timelineBounds.cadence[1]}\n                    />\n                    <Timeline\n                      attribute={Attribute.Pace}\n                      records={records}\n                      offsetIndex={offsetIndex}\n                      viewedDuration={viewedDuration}\n                      filter={this.state.filter}\n                      shouldConvertRpmToSpm={shouldConvertRpmToSpm}\n                      verticalMin={this.state.timelineBounds.pace[0]}\n                      verticalMax={this.state.timelineBounds.pace[1]}\n                    />\n                  </div>\n\n                  <SectionDivider />\n\n                  <div className=\"BoundsContainer\">\n                    <div className=\"SectionHeader\">Filters: </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Heart Rate</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingHeartRateMin}\n                          onChange={this.onChangePendingFilterHeartRateMin}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingHeartRateMax}\n                          onChange={this.onChangePendingFilterHeartRateMax}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                    </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Cadence</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingCadenceMin}\n                          onChange={this.onChangePendingFilterCadenceMin}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingCadenceMax}\n                          onChange={this.onChangePendingFilterCadenceMax}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                    </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Pace</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingPaceMin}\n                          onChange={this.onChangePendingFilterPaceMin}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.filter.pendingPaceMax}\n                          onChange={this.onChangePendingFilterPaceMax}\n                          onBlur={this.onSyncPendingFilterBounds}\n                        />\n                      </label>\n                    </div>\n                  </div>\n\n                  <SectionDivider />\n\n                  <div className=\"CumulativesContainer\">\n                    <div className=\"SectionHeader\">Filtered stats: </div>\n\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Total duration: </span>\n                      <span className=\"Value\">\n                        {getDurationFromSecs(cumulatives.totalDuration)}\n                      </span>\n                    </div>\n\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Total distance (mi): </span>\n                      <span className=\"Value\">\n                        {roundTo(metersToMiles(cumulatives.totalDistance), 2)}\n                      </span>\n                    </div>\n\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Average pace (min/mi): </span>\n                      <span className=\"Value\">\n                        {fractionalMinuteToPaceString(cumulatives.averagePace)}\n                      </span>\n                    </div>\n\n                    <div className=\"Entry\">\n                      <span className=\"Key\">Average heart rate (bpm): </span>\n                      <span className=\"Value\">\n                        {Math.floor(cumulatives.averageHeartRate)}\n                      </span>\n                    </div>\n                  </div>\n\n                  <SectionDivider />\n\n                  <div className=\"BoundsContainer\">\n                    <div className=\"SectionHeader\">Y-axis ranges: </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Heart Rate</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingHeartRateMin}\n                          onChange={this.onChangePendingTimelineHeartRateMin}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingHeartRateMax}\n                          onChange={this.onChangePendingTimelineHeartRateMax}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                    </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Cadence</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingCadenceMin}\n                          onChange={this.onChangePendingTimelineCadenceMin}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingCadenceMax}\n                          onChange={this.onChangePendingTimelineCadenceMax}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                    </div>\n\n                    <div className=\"Bound\">\n                      <div className=\"BoundAttribute\">Pace</div>\n                      <label className=\"BoundMinLabel\">\n                        Min:{\" \"}\n                        <input\n                          className=\"BoundMin\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingPaceMin}\n                          onChange={this.onChangePendingTimelinePaceMin}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                      <label className=\"BoundMaxLabel\">\n                        Max:{\" \"}\n                        <input\n                          className=\"BoundMax\"\n                          type=\"text\"\n                          pattern=\"\\d*\"\n                          value={this.state.timelineBounds.pendingPaceMax}\n                          onChange={this.onChangePendingTimelinePaceMax}\n                          onBlur={this.onSyncPendingTimelineBounds}\n                        />\n                      </label>\n                    </div>\n                  </div>\n\n                  <SectionDivider />\n\n                  <div className=\"LeafletMap\" ref={this.mapRef} />\n                </div>\n              </div>\n            );\n          },\n        })}\n      </div>\n    );\n  }\n\n  handleUpload() {\n    const { files } = this.fileRef.current!;\n    if (files !== null && \"object\" === typeof files && files.length > 0) {\n      const file = files[0];\n      const reader = new FileReader();\n      reader.addEventListener(\"loadend\", () => {\n        if (reader.error) {\n          throw reader.error;\n        } else {\n          const buffer = reader.result as ArrayBuffer;\n          new EasyFit({\n            force: true,\n            speedUnit: \"km/h\",\n            lengthUnit: \"m\",\n            temperatureUnit: \"kelvin\",\n            elapsedRecordField: true,\n            mode: \"cascade\",\n          }).parse(buffer, (error: any, data: any) => {\n            if (error) {\n              throw error;\n            } else {\n              const firstSession = data.activity.sessions[0];\n              const records = getActivityRecords(data.activity);\n              const endRecord = records[records.length - 1];\n\n              const activity = getActivity(data);\n\n              this.setState({\n                activity: Option.some({\n                  activity,\n\n                  startLocation: Qprom.fromPromise(\n                    reverseGeocode(\n                      firstSession.start_position_lat,\n                      firstSession.start_position_long\n                    )\n                  ),\n                  isStartLocationTruncated: true,\n                  endLocation: Qprom.fromPromise(\n                    reverseGeocode(\n                      endRecord.position_lat,\n                      endRecord.position_long\n                    )\n                  ),\n                  isEndLocationTruncated: true,\n\n                  offsetTime: getFirstRecordTimestampOrActivityStartTime(\n                    activity\n                  ),\n                  offsetIndex: 0,\n                  viewedDuration: STARTING_VIEWED_DURATION,\n\n                  cumulatives: getCumulatives(activity, this.state.filter),\n\n                  timelineScroll: Option.none(),\n                }),\n              });\n            }\n          });\n        }\n      });\n      reader.readAsArrayBuffer(file);\n    }\n  }\n\n  toggleIsStartLocationTruncated() {\n    this.setState((state) => ({\n      activity: state.activity.map((activity) => ({\n        ...activity,\n        isStartLocationTruncated: !activity.isStartLocationTruncated,\n      })),\n    }));\n  }\n\n  toggleIsEndLocationTruncated() {\n    this.setState((state) => ({\n      activity: state.activity.map((activity) => ({\n        ...activity,\n        isEndLocationTruncated: !activity.isEndLocationTruncated,\n      })),\n    }));\n  }\n\n  onMouseDown(event: React.MouseEvent) {\n    this.onPointerDown(event.target as Element, event.clientX, event.clientY);\n  }\n\n  onTouchStart(event: React.TouchEvent) {\n    const touch = event.touches[0];\n    this.onPointerDown(event.target as Element, touch.clientX, touch.clientY);\n  }\n\n  onPointerDown(target: Element, x: number, y: number) {\n    this.setState((state) => ({\n      mouseDownTarget: Option.some(target),\n      activity: state.activity.map((state) => ({\n        ...state,\n        timelineScroll: Option.some({\n          initialPointerLocation: { x, y },\n          initialOffsetTime: state.offsetTime,\n        }),\n      })),\n    }));\n  }\n\n  onMouseUp() {\n    this.onPointerUp();\n  }\n\n  onTouchEnd() {\n    this.onPointerUp();\n  }\n\n  onPointerUp() {\n    this.setState((state) => ({\n      activity: state.activity.map((state) => ({\n        ...state,\n        timelineScroll: Option.none(),\n      })),\n      mouseDownTarget: Option.none(),\n    }));\n  }\n\n  onMouseMove(event: React.MouseEvent) {\n    this.onPointerMove(event.clientX, event.clientY);\n  }\n\n  onTouchMove(event: React.TouchEvent) {\n    const touch = event.touches[0];\n    this.onPointerMove(touch.clientX, touch.clientY);\n  }\n\n  onPointerMove(x: number, y: number) {\n    if (this.minimapRef && this.minimapRef.current) {\n      if (this.isCursorDragged()) {\n        const rect = this.minimapRef.current.getBoundingClientRect();\n        const dx = x - rect.left;\n        const rawCompletionFactor = dx / rect.width;\n        const clampedCompletionFactor = clamp({\n          min: 0,\n          max: 1,\n          value: rawCompletionFactor,\n        });\n        this.setState((state) => ({\n          activity: state.activity.map((state) => {\n            const startTime = getFirstRecordTimestampOrActivityStartTime(\n              state.activity\n            );\n            const endTime = getLastRecordTimestampOrActivityEndTime(\n              state.activity\n            );\n            const offsetTime = lerpDate(\n              startTime,\n              endTime,\n              clampedCompletionFactor\n            );\n            return {\n              ...state,\n              offsetTime,\n              offsetIndex: getOffsetIndex(state.activity.records, offsetTime),\n            };\n          }),\n        }));\n      } else if (this.isTimelineDragged()) {\n        this.setState((state) => ({\n          activity: state.activity.map((activityState) => {\n            return activityState.timelineScroll.match({\n              none: () => activityState,\n              some: ({ initialPointerLocation, initialOffsetTime }) => {\n                const dx = x - initialPointerLocation.x;\n                const widthFactor = dx / window.innerWidth;\n                const deltaTime = -activityState.viewedDuration * widthFactor;\n                const newTimeMillis = initialOffsetTime.getTime() + deltaTime;\n                const startTime = getFirstRecordTimestampOrActivityStartTime(\n                  activityState.activity\n                );\n                const endTime = getLastRecordTimestampOrActivityEndTime(\n                  activityState.activity\n                );\n                const clampedMillis = clamp({\n                  min: startTime.getTime(),\n                  max: endTime.getTime(),\n                  value: newTimeMillis,\n                });\n                const newTime = new Date(clampedMillis);\n                const newIndex = getOffsetIndex(\n                  activityState.activity.records,\n                  newTime\n                );\n                return {\n                  ...activityState,\n                  offsetTime: newTime,\n                  offsetIndex: newIndex,\n                };\n              },\n            });\n          }),\n        }));\n      }\n    }\n  }\n\n  isCursorDragged(): boolean {\n    const { minimapRef } = this;\n    return this.state.mouseDownTarget.match({\n      none: () => false,\n      some: (target) =>\n        !!(\n          minimapRef &&\n          minimapRef.current &&\n          isOrIsAncestorOf(minimapRef.current, target)\n        ),\n    });\n  }\n\n  isTimelineDragged(): boolean {\n    return this.state.mouseDownTarget.match({\n      none: () => false,\n      some: (target) => target.tagName === \"CANVAS\",\n    });\n  }\n\n  onChangePendingFilterBound(\n    attribute: Attribute,\n    boundType: BoundType,\n    event: React.ChangeEvent\n  ) {\n    this.setState({\n      filter: this.state.filter.setPendingBound(\n        attribute,\n        boundType,\n        (event.target as HTMLInputElement).value\n      ),\n    });\n  }\n\n  onChangePendingTimelineBound(\n    attribute: Attribute,\n    boundType: BoundType,\n    event: React.ChangeEvent\n  ) {\n    this.setState({\n      timelineBounds: this.state.timelineBounds.setPendingBound(\n        attribute,\n        boundType,\n        (event.target as HTMLInputElement).value\n      ),\n    });\n  }\n\n  onSyncPendingFilterBounds() {\n    const filter = this.state.filter.syncPendingBoundsWithActualBounds();\n    this.setState({\n      filter,\n      activity: this.state.activity.map((state) => ({\n        ...state,\n        cumulatives: getCumulatives(state.activity, filter),\n      })),\n    });\n  }\n\n  onSyncPendingTimelineBounds() {\n    const timelineBounds = this.state.timelineBounds.syncPendingBoundsWithActualBounds();\n    this.setState({ timelineBounds });\n  }\n}\n\ninterface AppState {\n  activity: Option<ActivityViewState>;\n  mouseDownTarget: Option<Element>;\n  filter: Filter;\n  timelineBounds: Filter;\n}\n\ninterface ActivityViewState {\n  activity: Activity;\n\n  startLocation: Qprom<Address>;\n  isStartLocationTruncated: boolean;\n  endLocation: Qprom<Address>;\n  isEndLocationTruncated: boolean;\n\n  offsetTime: Date;\n  offsetIndex: number;\n  viewedDuration: number;\n\n  cumulatives: Cumulatives;\n\n  timelineScroll: Option<{\n    initialPointerLocation: { x: number; y: number };\n    initialOffsetTime: Date;\n  }>;\n}\n\ninterface LeafletState {\n  map: leaflet.Map;\n  currentMarker: leaflet.Marker;\n  startMarker: leaflet.Marker;\n  endMarker: leaflet.Marker;\n}\n\nconst STARTING_VIEWED_DURATION = 300e3;\nconst POLYLINE_POINTS = 60;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}